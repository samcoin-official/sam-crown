[World Documentation home page![light logo](https://mintcdn.com/tfh/vNgKkjbn9HQ46Vw7/logo/world-logo.svg?fit=max&auto=format&n=vNgKkjbn9HQ46Vw7&q=85&s=6b41ff1b547fcdde3e37c0adf5e665dc)![dark logo](https://mintcdn.com/tfh/vNgKkjbn9HQ46Vw7/logo/world-logo-white.svg?fit=max&auto=format&n=vNgKkjbn9HQ46Vw7&q=85&s=440961eef8a29cde95418220bceaad79)](https://docs.world.org/)

Search...

Ctrl K

Search...

Navigation

Commands

Verify

[Home](https://docs.world.org/) [Mini Apps](https://docs.world.org/mini-apps) [World ID](https://docs.world.org/world-id) [World Chain](https://docs.world.org/world-chain)

On this page

- [Using the command](https://docs.world.org/mini-apps/commands/verify#using-the-command)
- [Sending the command & handling the response](https://docs.world.org/mini-apps/commands/verify#sending-the-command-%26-handling-the-response)
- [Verifying the proof](https://docs.world.org/mini-apps/commands/verify#verifying-the-proof)
- [Success Result on World App](https://docs.world.org/mini-apps/commands/verify#success-result-on-world-app)

The verify command lets you use [incognito actions](https://docs.world.org/world-id/id/cloud) inside of your mini app. Incognito actions are a primitive of World ID and allow you to gate functionality behind a unique human check.To use incognito actions, first create one in the [Developer Portal](https://developer.worldcoin.org/).**Use Case:** This command is crucial for applications that require user verification to access certain features,
ensuring that only verified humans can perform actions. You can set up the incognito action limiting the number of times a user can perform an action.**Example:** An game that requires users to verify their identity before playing to have a bot free experience.

## [​](https://docs.world.org/mini-apps/commands/verify\#using-the-command)  Using the command

- Async handlers
- Event listeners

### [​](https://docs.world.org/mini-apps/commands/verify\#sending-the-command-%26-handling-the-response)  Sending the command & handling the response

MiniKit uses a slightly different input payload than IDKit. We do not need to pass in the `app_id`.

Copy

```
export type VerifyCommandInput = {
	action: string
	signal?: string
	verification_level?: VerificationLevel // Default: Orb
}

```

Copy

```
type MiniAppVerifyActionSuccessPayload = {
	status: 'success'
	proof: string
	merkle_root: string
	nullifier_hash: string
	verification_level: VerificationLevel
	version: number
}

```

app/page.tsx

Copy

```
import { MiniKit, VerifyCommandInput, VerificationLevel, ISuccessResult } from '@worldcoin/minikit-js'

const verifyPayload: VerifyCommandInput = {
	action: 'voting-action', // This is your action ID from the Developer Portal
	signal: '0x12312', // Optional additional data
	verification_level: VerificationLevel.Orb, // Orb | Device
}

const handleVerify = async () => {
	if (!MiniKit.isInstalled()) {
		return
	}
	// World App will open a drawer prompting the user to confirm the operation, promise is resolved once user confirms or cancels
	const {finalPayload} = await MiniKit.commandsAsync.verify(verifyPayload)
		if (finalPayload.status === 'error') {
			return console.log('Error payload', finalPayload)
		}

		// Verify the proof in the backend
		const verifyResponse = await fetch('/api/verify', {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
			},
			body: JSON.stringify({
			payload: finalPayload as ISuccessResult, // Parses only the fields we need to verify
			action: 'voting-action',
			signal: '0x12312', // Optional
		}),
	})

	// TODO: Handle Success!
	const verifyResponseJson = await verifyResponse.json()
	if (verifyResponseJson.status === 200) {
		console.log('Verification success!')
	}
}

```

## [​](https://docs.world.org/mini-apps/commands/verify\#verifying-the-proof)  Verifying the proof

You should pass the proof to your backend when verifying proofs via the API. Users can manipulate information in the
frontend, so the proof must be verified in a trusted environment.

Successful responses will return a `MiniAppVerifyActionSuccessPayload`.

Copy

```
type MiniAppVerifyActionSuccessPayload = {
	status: 'success'
	proof: string
	merkle_root: string
	nullifier_hash: string
	verification_level: VerificationLevel
	version: number
}

```

To verify the proof, you will need to make a backend route.

app/api/verify/route.ts

Copy

```
import { NextRequest, NextResponse } from 'next/server'
import { verifyCloudProof, IVerifyResponse, ISuccessResult } from '@worldcoin/minikit-js'

interface IRequestPayload {
	payload: ISuccessResult
	action: string
	signal: string | undefined
}

export async function POST(req: NextRequest) {
	const { payload, action, signal } = (await req.json()) as IRequestPayload
	const app_id = process.env.APP_ID as `app_${string}`
	const verifyRes = (await verifyCloudProof(payload, app_id, action, signal)) as IVerifyResponse // Wrapper on this

	if (verifyRes.success) {
		// This is where you should perform backend actions if the verification succeeds
		// Such as, setting a user as "verified" in a database
		return NextResponse.json({ verifyRes, status: 200 })
	} else {
		// This is where you should handle errors from the World ID /verify endpoint.
		// Usually these errors are due to a user having already verified.
		return NextResponse.json({ verifyRes, status: 400 })
	}
}

```

## [​](https://docs.world.org/mini-apps/commands/verify\#success-result-on-world-app)  Success Result on World App

If implemented correctly, the user will see the following drawer on World App.

Your browser does not support the video tag.

Was this page helpful?

YesNo

[Mini App Store](https://docs.world.org/mini-apps/quick-start/app-store) [Pay](https://docs.world.org/mini-apps/commands/pay)

Assistant

Responses are generated using AI and may contain mistakes.